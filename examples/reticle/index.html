
  <html>
	<head>
		<title>Reticle example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="../libs/three.min.js"></script>
 		<script module src="../../dist/webxr.js"></script>
		<link rel="stylesheet" href="../common.css"/>
	</head>
	<body>
		<script>	
				window.hideMe = function(elem) { elem.style.display = 'none' }
		</script>
		<div onclick="hideMe(this)" id="description">
			<h2>Reticle</h2>
			<h5>(click to dismiss)</h5>
			<p>Place a reticle on surfaces.</p>
		</div>
		<button type=button id=go-button>Go</button>
		<script type=module>
			/*
			Reticle Example shows how to find surfaces or other features and place reticle relative to them.

			In a production application, you would likely want to request world geometry, rather than only 
			using low level hit testing, and fall back to this method if the user declines to provide 
			real world geometry access.
			*/

			// some dependencies and utilities
			import * as mat4 from '../libs/gl-matrix/mat4.js'
			import * as vec3 from '../libs/gl-matrix/vec3.js'

			import XREngine from "../XREngine.js"
			import XRInputManager from "../XRInputManager.js"

			let device = null
			let session = null
			let headFrameOfReference = null
			let eyeLevelFrameOfReference = null
			let layer = null
			let frameOfReference = null
			let engine = null
			
			// temporary working variables
			const workingMatrix = mat4.create()
			const identity = mat4.identity(mat4.create())
			var savedOrigin = [0,0,0]
			var savedDirection = [0,0,-1]
			var reticleParent = new THREE.Object3D()
			var reticle = null
			
			var reticleTrackedColor = new THREE.MeshBasicMaterial({ color: '#DDFFDD' })
			var reticleNotTrackedColor = new THREE.MeshBasicMaterial({ color: '#FF6666' })
			var requestNextHit = true

			function initializeScene(){
				engine.addAmbientLight()
				engine.addDirectionalLight()

				// Add a box and axis at the origin of the eye-level coordinate system
				// for debugging by uncommenting these lines
				// engine.addBox([0, 0, 0], [0.025, 0.025, 0.025], 0x44ff44)
				// engine.addAxesHelper([0,0,0], [0.2,0.2,0.2])				
				
				reticle = new THREE.Mesh(
					new THREE.RingGeometry(0.04, 0.05, 36, 64),
					reticleTrackedColor
				)

				reticle.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(-90)))
				reticleParent.add(reticle)

				// var color = new THREE.Color( 0xffffff );
        		// color.setHex( Math.random() * 0xffffff );
				// const box = new THREE.Mesh(
				// 	new THREE.BoxBufferGeometry(0.025, 0.025, 0.025),
				// 	new THREE.MeshLambertMaterial({ color: color })
				// )
				// reticleParent.add(box)

				reticleParent.matrixAutoUpdate = false
				reticleParent.visible = false
				engine.scene.add(reticleParent)
			}
			
			// handle hit testing slightly differently than other samples, since we're doing
			// it per frame.  The "boiler plate" code below is slightly different, setting 
			// requestNextHit on tap instead of executing the hit test.  The custom XREngineHits
			// does a hit test each frame if the previous one has resolved
			function handleHitResults(hits) {
				let size = 0.05;
				if (hits.length > 0) {
					let hit = hits[0]

					// convert hit matrices from head to eye level coordinate systems
					const csTransform = headFrameOfReference.getTransformTo(eyeLevelFrameOfReference)
					mat4.multiply(workingMatrix, csTransform, hit.hitMatrix)

					const node = reticleParent
					node.matrix.fromArray(workingMatrix)
					reticleParent.visible = true   // it starts invisible
					reticle.material = reticleTrackedColor

					node.updateMatrixWorld(true)
				} else {
					reticle.material = reticleNotTrackedColor
				}
				requestNextHit = true
			}

			class XREngineHits extends XREngine {
				endFrame(){
					if (requestNextHit) {
						requestNextHit = false

						session.requestHitTest(savedOrigin, savedDirection, headFrameOfReference)
							.then(handleHitResults)
							.catch(err => {
								console.error('Error testing hits', err)
							})
					}
				}
			}

			////////////////////////////////////////////////////
			////////////////////////////////////////////////////
			// BOILER PLATE.  Can you feel the plates boiling?
			//
			// There are slight differences between examples but largely this code is similar
			//
			// Create the output context where the XRSession will place composited renders
			const xrCanvas = document.createElement('canvas')
			xrCanvas.setAttribute('class', 'xr-canvas')
			const xrContext = xrCanvas.getContext('xrpresent')
			if(!xrContext){
				console.error('No XR context', xrCanvas)
			}

			// get the XR Device
			navigator.xr.requestDevice().then(xrDevice => {
				device = xrDevice
			}).catch(err => {
			})

			document.getElementById('go-button').addEventListener('click', handleStartSessionRequest)

			// handle input events from the XRInputManager
			const inputManager = new XRInputManager(handleXRInput)
			function handleXRInput(eventName, details){
				switch(eventName){
					case 'normalized-touch':
						hitTestWithScreenCoordinates(...details.normalizedCoordinates)
						break
					default:
						console.error('unknown xr input event', eventName, details)
						break
				}
			}

			function hitTestWithScreenCoordinates(normalizedX, normalizedY){
				if(session === null){
					console.log('No session for hit testing')
					return
				}
				if(headFrameOfReference === null){
					console.log('No frame of reference')
					return
				}
				// Convert the screen coordinates into head-model origin/direction for hit testing
				const [origin, direction] = XRInputManager.convertScreenCoordinatesToRay(normalizedX, normalizedY, 
																							engine.camera.projectionMatrix)
				savedOrigin = origin
				savedDirection = direction

				requestNextHit = true
			}

			/////////////////////
			// Session startup / shutdown
			function handleStartSessionRequest(ev){
				if(device === null){
					console.error('No xr device')
					return
				}

				if (!session) {
					device.requestSession({ outputContext: xrContext })
						.then(handleSessionStarted)
						.catch(err => {
							console.error('Session setup error', err)
						})
					document.getElementById('go-button').value = "End"
				} else {
					session.end()
					handleSessionEnded();
					document.getElementById('go-button').value = "Go"
				}
			}

			function handleSessionEnded() {	
				session = null
			}

			function handleSessionStarted(xrSession){
				session = xrSession
				document.body.insertBefore(xrCanvas, document.body.firstChild)

				// Create the context where we will render our 3D scene
				const canvas = document.createElement('canvas')
				var glContext = canvas.getContext('webgl', {
					compatibleXRDevice: device
				})
				if(!glContext) throw new Error('Could not create a webgl context')

				// Set up the base layer
				session.baseLayer = new XRWebGLLayer(session, glContext)

				// Create a simple test scene and renderer
				// The engine's scene is in the eye-level coordinate system 
				// Our custom engine class does hit testing at the end of each rAF 
				engine = new XREngineHits(canvas, glContext)

				// head-model is the coordinate system that tracks the position of the display
				session.requestFrameOfReference('head-model').then(frameOfReference =>{
					headFrameOfReference = frameOfReference
				})
				.catch(err => {
					console.error('Error finding head frame of reference', err)
				})
				// eye-level is the coordinate system of the ARKit tracking system 
				session.requestFrameOfReference('eye-level').then(frameOfReference => {
					eyeLevelFrameOfReference = frameOfReference
					// Kick off rendering
					session.requestAnimationFrame(handleAnimationFrame)
				})
				.catch(err => {
					console.error('Error finding eye frame of reference', err)
				})

				initializeScene()
			}

			////////////////
			// render loop			
			function handleAnimationFrame(t, frame){
				if(session.ended) return
				session.requestAnimationFrame(handleAnimationFrame)

				let pose = frame.getDevicePose(eyeLevelFrameOfReference)
				if(!pose){
					console.log('No pose')
					return
				}

				engine.startFrame()
				for (let view of frame.views) {
					engine.render(
						session.baseLayer.getViewport(view),
						view.projectionMatrix,
						pose.getViewMatrix(view)
					)
					break
				}
				engine.endFrame()
			}

		</script>
	</body>
</html>